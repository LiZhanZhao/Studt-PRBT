
/*
    pbrt source code Copyright(c) 1998-2012 Matt Pharr and Greg Humphreys.

    This file is part of pbrt.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

    - Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    - Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */

#if defined(_MSC_VER)
#pragma once
#endif

#ifndef PBRT_CORE_FILM_H
#define PBRT_CORE_FILM_H

// core/film.h*
#include "pbrt.h"

// The File is responsible for writing the final image to disk and possibly displaying
// it on the screen as it is being computed

/*
P402

The type of film or sensor in a camera has a dramatic(¾ªÈËµÄ) effect on the way that incident
light is eventually transformed into colors in an image. In pbrt, the Film class models the
sensing device in the simulated camera. After the radiance is found for each camera ray,
a Film implementation determines the sample¡¯s contribution to the nearby pixels and
updates its representation of the image. When the main rendering loop exits, the Film
typically writes the final image to a file on disk.

This section only provides a single Film implementation. It applies the pixel reconstruction
equation to compute final pixel values and writes the image to disk with floatingpoint
color values.

*/

// Film Declarations
class Film {
public:
    // Film Interface
    Film(int xres, int yres)
        : xResolution(xres), yResolution(yres) { }
    virtual ~Film();

	/*
	is driven by Samples
	generated by the Sampler; for each such sample, Film::AddSample() is called. It takes
	a sample and corresponding radiance value, applies the reconstruction filter, and and
	updates the stored image.

	(the final pixel value
	is effectively a weighted average of the nearby samples.) Under this assumption, the pixel
	filtering equation can be used to compute the final values

	*/
    virtual void AddSample(const CameraSample &sample,
                           const Spectrum &L) = 0;

	/*

	Splatting similarly updates
	pixel values, but rather than computing the final pixel value as a weighted average, splats
	are simply summed.

	Thus, the more splats that are around a given pixel, the brighter
	the pixel will be. This method is used by light transport algorithms like the one in the
	MetropolisRenderer, where more samples are generated in areas where the image is
	brighter. It would also be used by bidrectional light transport algorithms that followed
	paths starting from lights and then projected illuminated points onto the film.
	*/
    virtual void Splat(const CameraSample &sample, const Spectrum &L) = 0;

	/*
	The Film is responsible for determining the range of integer pixel values that the Sampler
	is responsible for generating samples for. While this range would be from (0, 0) to
	(xResolution - 1, yResolution - 1) for a simple film implementation, in general it is
	necessary to sample the image plane at locations slightly beyond the edges of the final
	image due to the finite extent of pixel reconstruction filters. This range is returned by the
	GetSampleExtent() method.
	*/
    virtual void GetSampleExtent(int *xstart, int *xend,
                                 int *ystart, int *yend) const = 0;

	/*
	GetPixelExtent() provides the range of pixels in the actual image.
	*/
    virtual void GetPixelExtent(int *xstart, int *xend,
                                int *ystart, int *yend) const = 0;

	/*
	Some Film implementations find it useful to be notified that a region of the pixels has
	recently been updated. In particular, an implementation that opened a window to show
	the image as it was being rendered could use this information to trigger an update of a
	subregion of the window after its samples had been generated. Here we provide a default
	empty implementation of this method so that Film implementations that don¡¯t need this
	information don¡¯t need to implement it themselves.
	*/
    virtual void UpdateDisplay(int x0, int y0, int x1, int y1, float splatScale = 1.f);

	/*
	After the main rendering loop exits, the SamplerRenderer::Render() method calls the
	Film::WriteImage() method, which allows the film to do any processing necessary to
	generate the final image and display it or store it in a file
	*/
    virtual void WriteImage(float splatScale = 1.f) = 0;

    // Film Public Data
    const int xResolution, yResolution;
};



#endif // PBRT_CORE_FILM_H
